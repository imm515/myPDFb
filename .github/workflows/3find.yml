name: 3find

on:
  workflow_dispatch:
    inputs:
      work_directory:
        description: "请输入工作目录名称 (例如: cb202508)。留空则默认上个月。"
        required: false
        type: string
      suffix:
        description: "可选后缀"
        required: false
        type: choice
        options:
          - ""
          - 伙食
  workflow_run:
    workflows: ["2name"]
    types:
      - completed

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  file-matcher:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    env:
      WORK_DIR_FILE: "${{ secrets.PRIVATE_DIR }}/myPDF工作目录.v"

    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo
          ref: main

      - name: Resolve WORK_DIR (Conditional)
        id: read_work_dir
        run: |
          # 获取上下文信息
          event_name="${{ github.event_name }}"
          input_dir="${{ github.event.inputs.work_directory }}"
          suffix="${{ github.event.inputs.suffix }}"
          work_dir_file="private-repo/$WORK_DIR_FILE"
          work_dir_name=""

          # =======================================================
          # 步骤 1: 根据触发事件类型确定基础 work_dir_name
          # =======================================================

          if [ "$event_name" == "workflow_run" ]; then
              # Case A: 由 2name 自动触发
              # 仅从文件读取，确保继承自 1cut/2name
              
              if [ -f "$work_dir_file" ]; then
                  # 从文件中读取，忽略注释和空行
                  work_dir_name=$(grep -v -e '^#' -e '^$' "$work_dir_file" | head -n 1 | xargs)
                  echo "::notice::自动触发：从文件读取工作目录：$work_dir_name"
              else
                  echo "::error::自动触发失败：未找到 $WORK_DIR_FILE 文件，无法确定工作目录。"
                  exit 1
              fi

          elif [ "$event_name" == "workflow_dispatch" ]; then
              # Case B: 手动触发 (使用新版逻辑：输入优先，否则默认上个月)
              
              if [ -n "$input_dir" ]; then
                  work_dir_name="$input_dir"
                  echo "::notice::手动触发：使用输入目录：$work_dir_name"
              else
                  last_month=$(date -d "$(date +%Y-%m-15) -1 month" +%Y%m)
                  work_dir_name="cb${last_month}"
                  echo "::notice::手动触发：输入为空，默认上个月目录：$work_dir_name"
              fi
          
          else
              echo "::error::未知触发事件类型：$event_name"
              exit 1
          fi

          # =======================================================
          # 步骤 2: 后续通用处理
          # =======================================================

          # 2) 后缀处理 (仅在手动触发时且输入了后缀才处理)
          if [ "$event_name" == "workflow_dispatch" ] && [ -n "$suffix" ] && [[ "$work_dir_name" != *"$suffix" ]]; then
              work_dir_name="${work_dir_name}${suffix}"
              echo "::notice::已添加后缀：$suffix"
          fi
          
          # 3) 合法性校验 (无论哪种情况，都必须校验最终结果)
          if [ -z "$work_dir_name" ] || [[ ! "$work_dir_name" =~ ^cb[0-9]{6}(伙食)?$ ]]; then
              echo "::error::目录名不合法或为空：$work_dir_name，必须是 cbYYYYMM 或 cbYYYYMM伙食 格式"
              exit 1
          fi

          # 4) 写回文件，保证下次默认使用本次运行结果 (此步骤保持，确保 2name 的正确值被覆盖)
          echo "$work_dir_name" > "$work_dir_file"

          echo "::notice::最终工作目录：$work_dir_name"
          echo "WORK_DIR=${{ secrets.PRIVATE_DIR }}/$work_dir_name" >> $GITHUB_ENV

      - name: 使用工作目录
        run: |
          echo "✅ 工作目录是：$WORK_DIR"
          echo "SOURCE_DIR=$WORK_DIR/2name" >> $GITHUB_ENV
          echo "TARGET_DIR=$WORK_DIR/3查找" >> $GITHUB_ENV

      - name: 查找查找单号文件（无后缀或 .v 后缀）
        run: |
          SEARCH_CANDIDATE_1="$WORK_DIR/#查找单号"
          SEARCH_CANDIDATE_2="$WORK_DIR/#查找单号.v"

          if [ -f "private-repo/$SEARCH_CANDIDATE_1" ]; then
            MATCHED_SEARCH="$SEARCH_CANDIDATE_1"
          elif [ -f "private-repo/$SEARCH_CANDIDATE_2" ]; then
            MATCHED_SEARCH="$SEARCH_CANDIDATE_2"
          else
            echo "::error::未找到查找单号文件。请确保存在：'$SEARCH_CANDIDATE_1' 或 '$SEARCH_CANDIDATE_2'"
            exit 1
          fi

          echo "SEARCH_FILE=$MATCHED_SEARCH" >> $GITHUB_ENV
          echo "✅ 识别到查找单号文件：$MATCHED_SEARCH"

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pymupdf

      - name: Initialize directories
        run: |
          cd private-repo
          rm -rf "$TARGET_DIR"
          echo "♻️ 已清空旧 3查找 目录：$TARGET_DIR"
          mkdir -p "$TARGET_DIR"
          if [ ! -f "$SEARCH_FILE" ]; then
            echo "::error::查找单号文件不存在：$SEARCH_FILE"
            exit 1
          fi

      - name: Process number matching
        run: |
          cd private-repo
          python3 <<EOF
          import os, re, shutil
          from pathlib import Path
          import fitz

          source_dir = Path(os.getenv("SOURCE_DIR"))
          target_dir = Path(os.getenv("TARGET_DIR"))
          search_file = Path(os.getenv("SEARCH_FILE"))

          search_numbers = []
          with open(search_file, 'r') as f:
              for line in f:
                  line = line.strip()
                  if line.startswith('#') or not line:
                      continue
                  if '--' in line:
                      num = line.split('--')[-1].strip()
                  else:
                      num = line.split()[0].strip()
                  if num.isdigit():
                      search_numbers.append(f"{int(num):04d}")
          print(f"需要查找的编号：{search_numbers}")

          target_dir.mkdir(parents=True, exist_ok=True)
          copied_files = []
          for file_path in source_dir.glob('**/*.pdf'):
              match = re.match(r'^(\d{4})_', file_path.name)
              if not match:
                  continue
              file_num = match.group(1)
              if file_num in search_numbers:
                  pdf = fitz.open(file_path)
                  page = pdf.load_page(0)
                  rect = page.rect
                  font = fitz.Font("helv")
                  text = str(int(file_num))
                  text_length = font.text_length(text, fontsize=8)
                  pos = fitz.Point(rect.width - 10 - text_length, rect.height - 10)
                  page.insert_text(pos, text, fontname="helv", fontsize=8, color=(0.5,0.5,0.5))
                  tgt_pdf = target_dir / file_path.name
                  cnt = 1
                  while tgt_pdf.exists():
                      tgt_pdf = target_dir / f"{file_num}_{cnt:02d}{file_path.suffix}"
                      cnt += 1
                  pdf.save(tgt_pdf)
                  pdf.close()
                  copied_files.append(tgt_pdf.name)
                  txt_path = file_path.with_suffix('.txt')
                  if txt_path.exists():
                      tgt_txt = target_dir / txt_path.name
                      cnt = 1
                      while tgt_txt.exists():
                          tgt_txt = target_dir / f"{file_num}_{cnt:02d}{txt_path.suffix}"
                          cnt += 1
                      shutil.copy2(txt_path, tgt_txt)
                      copied_files.append(tgt_txt.name)

          print(f"\n成功复制 {len(copied_files)} 个文件：")
          print('\n'.join(copied_files))
          if not copied_files:
              print("::warning::没有找到匹配的文件！")
              exit(78)
          EOF

      - name: Commit and push results
        run: |
          cd private-repo
          git config user.email "file-matcher@auto"
          git config user.name "File Matcher"

          file_count=$(find "$TARGET_DIR" -type f | wc -l)
          commit_msg="Auto: 找到并复制 $file_count 个匹配文件（包含 PDF 和 TXT）"

          git add "$TARGET_DIR" "$WORK_DIR_FILE"
          if git diff --cached --quiet; then
            echo "No changes to commit. Skipping."
            exit 0
          fi
          git commit -m "$commit_msg"
          git push "https://x-access-token:${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git" main
