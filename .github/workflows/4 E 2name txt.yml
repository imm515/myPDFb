name: 4 png txt 2name

on:
  workflow_dispatch:
    inputs:
      clean_run:
        description: '是否清空旧2name目录？'
        required: false
        default: 'true'

jobs:
  process-naming:
    runs-on: ubuntu-latest
    env:
      SOURCE_DIR: ${{ secrets.PRIVATE_DIR }}/1cut
      DEST_DIR: ${{ secrets.PRIVATE_DIR }}/2name

    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo
          ref: main

      - name: Initialize workspace
        run: |
          cd private-repo
          # 根据参数决定是否清空旧目录
          if [ "${{ github.event.inputs.clean_run }}" = "true" ]; then
            rm -rf "$DEST_DIR"
            echo "♻️ 已清空旧2name目录"
          fi
          mkdir -p "$DEST_DIR"

      - name: Process files based on TXT content
        run: |
          cd private-repo
          # 将 Python 逻辑写入临时脚本
          cat << 'EOF' > process_files.py
          import os
          import re

          SOURCE = os.getenv("SOURCE_DIR")
          DEST = os.getenv("DEST_DIR")

          # 获取已存在的最大序号
          existing_files = [f for f in os.listdir(DEST) if f.endswith('.png')]
          counter = max([int(f.split('_')[0]) for f in existing_files]) if existing_files else 0

          # 按自然顺序处理文件
          all_files = []
          for root, _, files in os.walk(SOURCE):
              for f in files:
                  if f.endswith('.png') and any(part in f for part in ['1top', '2mid', '3bot']):
                      all_files.append(os.path.join(root, f))

          # 自然排序算法
          def natural_sort_key(s):
              return [int(text) if text.isdigit() else text.lower()
                      for text in re.split(r'(\d+)', s)]

          all_files.sort(key=natural_sort_key)

          # 主处理循环
          for filepath in all_files:
              filename = os.path.basename(filepath)
              match = re.search(r'p(\d+)_(1top|2mid|3bot)', filename)
              if not match:
                  continue

              page_num = match.group(1)
              part_type = match.group(2)

              # 查找对应的 TXT 文件
              txt_path = filepath.replace('.png', '.txt')

              # 判断 TXT 文件是否为空
              if os.path.exists(txt_path):
                  with open(txt_path, 'r', encoding='utf-8') as f:
                      content = f.read().strip()
                  if content:  # 如果 TXT 文件不为空
                      counter += 1
                      new_name = f"{counter:04d}_{page_num}{part_type}"
                      # 复制 PNG 文件
                      os.system(f"cp '{filepath}' '{os.path.join(DEST, new_name)}.png'")
                      # 复制 TXT 文件
                      os.system(f"cp '{txt_path}' '{os.path.join(DEST, new_name)}.txt'")
                      print(f"Processed: {filename} → {new_name}.png & .txt")
                  else:
                      # 如果 TXT 文件为空，删除对应的 PNG 和 TXT 文件
                      os.remove(filepath)
                      os.remove(txt_path)
                      print(f"Deleted empty: {filename} and {os.path.basename(txt_path)}")
              else:
                  print(f"TXT file not found for: {filename}")
          EOF

          # 运行 Python 脚本
          python3 process_files.py

      - name: Commit and push results
        run: |
          cd private-repo
          git config user.email "doc-processor@auto"
          git config user.name "Document Processor"

          # 生成智能提交信息
          file_count=$(find "$DEST_DIR" -type f -name "*.png" | wc -l)
          commit_msg="Auto: Generated $file_count named slices and paired TXT files"

          git add "$DEST_DIR"
          git commit -m "$commit_msg"
          git push "https://x-access-token:${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git" main
