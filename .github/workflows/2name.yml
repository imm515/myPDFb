name: 2name

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["1cut"]
    types:
      - completed

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  process-naming:
    runs-on: ubuntu-latest
    env:
      WORK_DIR_FILE: "${{ secrets.PRIVATE_DIR }}/myPDF工作目录.v"

    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo
          ref: main

      - name: Read WORK_DIR from file
        id: read_work_dir
        run: |
          WORK_DIR=$(grep -v -e '^#' -e '^$' "private-repo/$WORK_DIR_FILE" | head -n 1)
          if [ -z "$WORK_DIR" ]; then
            echo "Error: No valid WORK_DIR found in $WORK_DIR_FILE"
            exit 1
          fi
          echo "WORK_DIR=${{ secrets.PRIVATE_DIR }}/$WORK_DIR" >> $GITHUB_ENV
          echo "SOURCE_DIR=${{ secrets.PRIVATE_DIR }}/$WORK_DIR/1cut" >> $GITHUB_ENV
          echo "DEST_DIR=${{ secrets.PRIVATE_DIR }}/$WORK_DIR/2name" >> $GITHUB_ENV

      - name: Initialize workspace
        run: |
          cd private-repo
          rm -rf "${{ env.DEST_DIR }}"
          echo "♻️ 已清空旧2name目录"
          mkdir -p "${{ env.DEST_DIR }}"

      - name: Install Ghostscript
        run: |
          sudo apt-get update
          sudo apt-get install -y ghostscript

      - name: Process files based on TXT content
        run: |
          cd private-repo
          cat << 'EOF' > process_files.py
          import os
          import re
          import subprocess
          import shutil
          
          SOURCE = os.getenv("SOURCE_DIR")
          DEST = os.getenv("DEST_DIR")
          existing_files = [f for f in os.listdir(DEST) if f.endswith('.pdf')]
          counter = max([int(f.split('_')[0]) for f in existing_files]) if existing_files else 0
          all_files = []
          
          for root, _, files in os.walk(SOURCE):
              for f in files:
                  if f.endswith('.pdf') and any(part in f for part in ['1top', '2mid', '3bot']):
                      all_files.append(os.path.join(root, f))
          
          def natural_sort_key(s):
              return [int(text) if text.isdigit() else text.lower()
                      for text in re.split(r'(\d+)', s)]
          
          all_files.sort(key=natural_sort_key)
          
          def is_pdf_empty(pdf_path):
              # 创建一个临时目录
              temp_dir = "/tmp/ghostscript_temp"
              os.makedirs(temp_dir, exist_ok=True)
              
              # 将文件复制到临时目录（避免路径中的中文字符和空格问题）
              temp_pdf = os.path.join(temp_dir, "temp_input.pdf")
              shutil.copy(pdf_path, temp_pdf)
              
              # 使用 Ghostscript 将 PDF 转换为 PNG
              temp_output = os.path.join(temp_dir, "temp_output.png")
              command = f'gs -sDEVICE=png16m -dNOPAUSE -dBATCH -dQUIET -r150 -sOutputFile="{temp_output}" "{temp_pdf}"'
              try:
                  subprocess.run(command, shell=True, check=True)
              except subprocess.CalledProcessError as e:
                  print(f"Ghostscript failed to process {pdf_path}: {e}")
                  shutil.rmtree(temp_dir)
                  return False
              
              # 检查 PNG 文件大小
              file_size = os.path.getsize(temp_output)
              shutil.rmtree(temp_dir)
              return file_size < 50 * 1024  # 小于 50 KB 认为是空白
          
          for filepath in all_files:
              filename = os.path.basename(filepath)
              match = re.search(r'p(\d+)_(1top|2mid|3bot)', filename)
              if not match:
                  continue
              page_num = match.group(1)
              part_type = match.group(2)
              txt_path = filepath.replace('.pdf', '.txt')
          
              if os.path.exists(txt_path):
                  with open(txt_path, 'r', encoding='utf-8') as f:
                      content = f.read().strip()
                  if content:
                      counter += 1
                      # 更新命名方式：<counter>_<page_num><part_type>
                      new_name = f"{counter:04d}_{page_num}{part_type}"
                      os.system(f"cp '{filepath}' '{os.path.join(DEST, new_name)}.pdf'")
                      os.system(f"cp '{txt_path}' '{os.path.join(DEST, new_name)}.txt'")
                      #print(f"Processed: {filename} → {new_name}.pdf & .txt")
                      print(f"Processed: filename → {new_name}.pdf & .txt")                      
                  else:
                      # 如果 TXT 是空白的，检查 PDF 是否也是空白的
                      if is_pdf_empty(filepath):
                          os.remove(filepath)
                          os.remove(txt_path)
                          #print(f"Deleted empty: {filename} and {os.path.basename(txt_path)}")
                          print(f"Deleted empty: filename and os.path.basename(txt_path)")
                      else:
                          # 如果 PDF 不是空白的，保留文件并继续处理
                          counter += 1
                          new_name = f"{counter:04d}_{page_num}{part_type}"
                          os.system(f"cp '{filepath}' '{os.path.join(DEST, new_name)}.pdf'")
                          os.system(f"cp '{txt_path}' '{os.path.join(DEST, new_name)}.txt'")
                          print(f"Processed (no text but PDF has content): filename → {new_name}.pdf & .txt")
              else:
                  print(f"TXT file not found for: filename")
          EOF
          python3 process_files.py

      - name: Commit and push results
        run: |
          cd private-repo
          git config user.email "doc-processor@auto"
          git config user.name "Document Processor"

          file_count=$(find "${{ env.DEST_DIR }}" -type f -name "*.pdf" | wc -l)
          commit_msg="Auto: Generated $file_count named slices and paired TXT files"

          git add "${{ env.DEST_DIR }}"
          if git diff --cached --quiet; then
            echo "No staged changes to commit. Skipping commit and push."
            exit 0
          fi
          git commit -m "$commit_msg" > /dev/null 2>&1
          git push "https://x-access-token:${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git" main
