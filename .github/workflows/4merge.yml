name: 4merge

on:
  workflow_dispatch:

  workflow_run:
    workflows: ["3find"]
    types:
      - completed

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  pdf-merger:
    #if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    env:
      SOURCE_DIR: ${{ secrets.PRIVATE_DIR }}/3查找
      OUTPUT_DIR: ${{ secrets.PRIVATE_DIR }}/4拼接PDF

    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo
          ref: main

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libjpeg-dev zlib1g-dev
          pip install pymupdf

      - name: Prepare workspace
        run: |
          cd private-repo
          mkdir -p "$OUTPUT_DIR"
          echo "开始拼接PDF" > merge.log

      - name: Merge PDFs with optimization
        run: |
          cd private-repo
          python3 <<EOF
          import os
          import fitz  # PyMuPDF
          from pathlib import Path
          import re

          # 配置参数
          SOURCE_DIR = Path(os.getenv("SOURCE_DIR"))
          OUTPUT_DIR = Path(os.getenv("OUTPUT_DIR"))
          OUTPUT_PDF_PATH = OUTPUT_DIR / "merged_optimized.pdf"

          # 获取排序后的PDF文件列表
          def natural_sort_key(s):
              return [int(text) if text.isdigit() else text.lower()
                      for text in re.split(r'(\d+)', os.path.basename(s))]

          pdf_files = []
          for root, _, files in os.walk(SOURCE_DIR):
              for f in files:
                  if f.lower().endswith('.pdf'):
                      pdf_files.append(Path(root) / f)
          pdf_files.sort(key=natural_sort_key)

          # 创建一个新的PDF文档
          new_pdf = fitz.open()

          # 处理每个PDF文件
          for pdf_file in pdf_files:
              print(f"处理文件：{pdf_file.name}")
              pdf_doc = fitz.open(pdf_file)
              new_pdf.insert_pdf(pdf_doc)
              pdf_doc.close()

          # 保存并优化PDF
          new_pdf.save(OUTPUT_PDF_PATH, garbage=4, deflate=True, clean=True)
          new_pdf.close()

          print(f"成功生成优化后的PDF：{OUTPUT_PDF_PATH}")
          EOF

      - name: Merge TXT files with strict check
        run: |
          cd private-repo
          python3 <<EOF
          import os
          import fitz  # PyMuPDF
          from pathlib import Path
          import re
          
          # 配置参数
          SOURCE_DIR = Path(os.getenv("SOURCE_DIR"))
          OUTPUT_DIR = Path(os.getenv("OUTPUT_DIR"))
          OUTPUT_PDF_PATH = OUTPUT_DIR / "merged_optimized.pdf"
          
          # 获取排序后的PDF文件列表
          def natural_sort_key(s):
              return [int(text) if text.isdigit() else text.lower()
                      for text in re.split(r'(\d+)', os.path.basename(s))]
          
          pdf_files = []
          for root, _, files in os.walk(SOURCE_DIR):
              for f in files:
                  if f.lower().endswith('.pdf'):
                      pdf_files.append(Path(root) / f)
          pdf_files.sort(key=natural_sort_key)
          
          # 创建一个新的PDF文档
          new_pdf = fitz.open()
          
          # 处理每个PDF文件
          for pdf_file in pdf_files:
              print(f"处理文件：{pdf_file.name}")
              pdf_doc = fitz.open(pdf_file)
              
              # 遍历每个页面
              for page in pdf_doc:
                  # 获取页面中的所有图像
                  image_list = page.get_images(full=True)
                  for img in image_list:
                      xref = img[0]  # 图像的交叉引用编号
                      pix = fitz.Pixmap(pdf_doc, xref)  # 获取图像像素数据
                      
                      # 如果图像不是灰度或 RGB，转换为 RGB
                      #if pix.n > 4:
                          #pix = fitz.Pixmap(fitz.csRGB, pix)
                      
                      # 压缩图像（降低 JPEG 质量）
                      pix.save("temp.jpg", jpg_quality=75)  # 调整质量参数（75 是中等质量）
                      
                      # 将压缩后的图像替换回页面
                      page.replace_image(xref, filename="temp.jpg")
                  
                  # 将处理后的页面插入新 PDF
                  new_pdf.insert_pdf(pdf_doc, from_page=page.number, to_page=page.number)
              
              pdf_doc.close()
          
          # 保存并优化 PDF
          new_pdf.save(OUTPUT_PDF_PATH, garbage=4, deflate=True, clean=True, pretty=True)
          new_pdf.close()
          
          print(f"成功生成优化后的PDF：{OUTPUT_PDF_PATH}")
          EOF

      - name: Commit results
        run: |
          cd private-repo
          git config user.email "pdf-merger@auto"
          git config user.name "PDF Merger"

          # 生成版本号
          timestamp=$(date +%Y%m%d%H%M%S)
          commit_msg="Auto: 生成优化拼接PDF和汇总TXT（v$timestamp）"

          # 添加更改到暂存区
          git add "$OUTPUT_DIR"

          # 检查是否有 staged 的更改
          if git diff --cached --quiet; then
            echo "No staged changes to commit. Skipping commit and push."
            exit 0
          fi

          # 如果有 staged 的更改，则提交并推送
          git commit -m "$commit_msg"
          git push "https://x-access-token:${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git" main
