name: 4merge

on:
  workflow_dispatch:

  workflow_run:
    workflows: ["3find"]
    types:
      - completed

concurrency:
  group: ${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  pdf-merger:
    runs-on: ubuntu-latest
    env:
      SOURCE_DIR: ${{ secrets.PRIVATE_DIR }}/3查找
      OUTPUT_DIR: ${{ secrets.PRIVATE_DIR }}/4拼接PDF
      SEARCH_FILE: ${{ secrets.PRIVATE_DIR }}/#查找单号

    steps:
      - name: Checkout private repo
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo
          ref: main

      - name: Install Ghostscript
        run: |
          sudo apt-get update
          sudo apt-get install -y ghostscript

      - name: Prepare workspace
        run: |
          cd private-repo
          mkdir -p "$OUTPUT_DIR"
          echo "开始拼接PDF" > merge.log

      - name: Read search numbers from file
        id: read_search_numbers
        run: |
          cd private-repo
          search_numbers=()
          while IFS= read -r line; do
            # 跳过注释和空行
            if [[ ! "$line" =~ ^# && -n "$line" ]]; then
              # 提取数字部分（支持两种格式）
              if [[ "$line" == *"--"* ]]; then
                num=$(echo "$line" | awk -F'--' '{print $NF}' | xargs)
              else
                num=$(echo "$line" | awk '{print $1}' | xargs)
              fi
              if [[ "$num" =~ ^[0-9]+$ ]]; then
                search_numbers+=($(printf "%04d" "$num"))
              else
                echo "::error::查找单号文件中包含无效数字：$line"
                exit 1
              fi
            fi
          done < "$SEARCH_FILE"

          if [ ${#search_numbers[@]} -eq 0 ]; then
            echo "::error::查找单号文件中未找到有效编号！"
            exit 1
          fi

          echo "需要查找的编号：${search_numbers[@]}"
          echo "search_numbers=$(IFS=,; echo "${search_numbers[*]}")" >> $GITHUB_ENV

      - name: Merge and compress PDFs with Ghostscript
        run: |
          cd private-repo
          # 获取所有PDF文件并按自然顺序排序
          pdf_files=()
          for num in "${search_numbers[@]}"; do
            pdf_path=$(find "$SOURCE_DIR" -type f -name "${num}_*.pdf" | sort -V)
            if [ -n "$pdf_path" ]; then
              pdf_files+=("$pdf_path")
              echo "找到匹配的PDF文件：$pdf_path"
            else
              echo "::warning::未找到匹配的PDF文件：${num}_*.pdf"
            fi
          done

          if [ ${#pdf_files[@]} -eq 0 ]; then
            echo "::error::未找到匹配的PDF文件！"
            exit 1
          fi

          # 使用Ghostscript合并并压缩PDF
          gs -sDEVICE=pdfwrite \
             -dCompatibilityLevel=1.4 \
             -dPDFSETTINGS=/printer \
             -dNOPAUSE \
             -dQUIET \
             -dBATCH \
             -sOutputFile="${OUTPUT_DIR}/merged_compressed.pdf" \
             "${pdf_files[@]}"

          echo "成功生成合并并压缩后的PDF：${OUTPUT_DIR}/merged_compressed.pdf"

      - name: Merge TXT files with strict check
        run: |
          cd private-repo
          output_txt_path="${OUTPUT_DIR}/merged.txt"
          > "$output_txt_path"  # 清空文件

          # 合并TXT文件内容
          for num in "${search_numbers[@]}"; do
            txt_path=$(find "$SOURCE_DIR" -type f -name "${num}_*.txt" | sort -V)
            if [ -n "$txt_path" ]; then
              # 检查对应的PDF文件是否存在
              pdf_path="${txt_path%.txt}.pdf"
              if [ ! -f "$pdf_path" ]; then
                echo "::error::TXT文件缺少对应的PDF文件：$txt_path"
                exit 1
              fi
              cat "$txt_path" >> "$output_txt_path"
              echo -e "\n\n" >> "$output_txt_path"  # 每个TXT文件后插入两个空行
            else
              echo "::warning::未找到匹配的TXT文件：${num}_*.txt"
            fi
          done

          echo "成功合并TXT文件到：$output_txt_path"

      - name: Commit results
        run: |
          cd private-repo
          git config user.email "pdf-merger@auto"
          git config user.name "PDF Merger"

          # 生成版本号
          timestamp=$(date +%Y%m%d%H%M%S)
          commit_msg="Auto: 生成优化拼接PDF和汇总TXT（v$timestamp）"

          # 添加更改到暂存区
          git add "$OUTPUT_DIR"

          # 检查是否有 staged 的更改
          if git diff --cached --quiet; then
            echo "No staged changes to commit. Skipping commit and push."
            exit 0
          fi

          # 如果有 staged 的更改，则提交并推送
          git commit -m "$commit_msg"
          git push "https://x-access-token:${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git" main
