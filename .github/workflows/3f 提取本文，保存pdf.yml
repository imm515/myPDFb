name: 3F Secure PDF Processing

on:
  workflow_dispatch:

jobs:
  process-pdf:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repositories
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PRIVATE_REPO }}
          token: ${{ secrets.PAT }}
          path: private-repo

      - name: Setup environment
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip ghostscript exiftool qpdf
          pip3 install PyMuPDF pypdf

      - name: Clean output directory
        run: |
          OUTPUT_DIR="$GITHUB_WORKSPACE/private-repo/${{ secrets.PRIVATE_DIR }}/1cut"
          [ -d "$OUTPUT_DIR" ] && find "$OUTPUT_DIR" -mindepth 1 -delete || mkdir -p "$OUTPUT_DIR"
          sudo chmod -R 777 "$OUTPUT_DIR"

      - name: Process PDFs
        run: |
          OUTPUT_DIR="$GITHUB_WORKSPACE/private-repo/${{ secrets.PRIVATE_DIR }}/1cut"

          cat << 'EOF' > process_pdf.py
          import fitz, os, sys, subprocess, tempfile
          from pypdf import PdfWriter, PdfReader

          def deep_clean_pdf(input_path, output_path):
              """深度清理PDF元数据和隐藏内容"""
              # 使用Ghostscript清理
              subprocess.run([
                  'gs', '-q',
                  '-o', output_path,
                  '-sDEVICE=pdfwrite',
                  '-dPDFSETTINGS=/prepress',
                  '-dColorConversionStrategy=/sRGB',
                  '-dProcessColorModel=/DeviceRGB',
                  '-dCompatibilityLevel=1.7',
                  '-dDetectDuplicateImages=true',
                  '-dCompressFonts=true',
                  '-dNOPAUSE',
                  '-dQUIET',
                  '-dBATCH',
                  input_path
              ], check=True)

              # 使用pypdf清理元数据
              with open(output_path, 'rb') as f:
                  reader = PdfReader(f)
                  writer = PdfWriter()
                  
                  for page in reader.pages:
                      writer.add_page(page)
                  
                  # 移除所有元数据
                  writer.add_metadata({})
                  
                  with open(output_path, 'wb') as f:
                      writer.write(f)

          def sanitize_pdf(input_path, output_path, crop_box):
              """安全裁剪PDF"""
              with fitz.open(input_path) as doc:
                  new_doc = fitz.open()
                  new_doc.insert_pdf(doc)
                  new_doc[0].set_cropbox(crop_box)
                  new_doc.save(output_path)
                  new_doc.close()
              
              # 深度清理
              deep_clean_pdf(output_path, output_path)

          def split_pdf(pdf_path, output_dir):
              with fitz.open(pdf_path) as doc:  # 确保文档对象正确管理
                  base = os.path.splitext(os.path.basename(pdf_path))[0]
                  
                  for pg in range(len(doc)):
                      page = doc[pg]
                      media_box = page.mediabox
                      width, height = media_box.x1, media_box.y1

                      for part in ["1top", "2mid", "3bot"]:
                          if part == "1top":
                              crop = fitz.Rect(0, 0, width, height/3)
                          elif part == "2mid":
                              crop = fitz.Rect(0, height/3, width, 2*height/3)
                          else:
                              crop = fitz.Rect(0, 2*height/3, width, height)

                          final_name = f"{base}_p{pg+1}_{part}"
                          final_pdf = f"{output_dir}/{final_name}.pdf"
                          txt_file = f"{output_dir}/{final_name}.txt"
                          
                          try:
                              sanitize_pdf(pdf_path, final_pdf, crop)
                              
                              # 文本提取（从清理后的文件）
                              with fitz.open(final_pdf) as clean_doc:
                                  text = clean_doc[0].get_text()
                                  with open(txt_file, "w", encoding="utf-8") as f:
                                      f.write(text.strip())
                              
                              # 最终验证
                              subprocess.run(["exiftool", "-overwrite_original", "-all=", final_pdf])
                              subprocess.run(["qpdf", "--linearize", final_pdf, final_pdf+".tmp"])
                              os.rename(final_pdf+".tmp", final_pdf)

                          except Exception as e:
                              print(f"处理失败: {final_name} - {str(e)}")

          if __name__ == "__main__":
              if len(sys.argv) != 3:
                  print("Usage: python process_pdf.py <input_pdf> <output_dir>")
                  sys.exit(1)
              split_pdf(sys.argv[1], sys.argv[2])
          EOF

          # 处理根目录PDF
          find "private-repo/${{ secrets.PRIVATE_DIR }}" -maxdepth 1 -name "*.pdf" -print0 | while IFS= read -r -d $'\0' file; do
              echo "Processing: $file"
              python3 process_pdf.py "$file" "$OUTPUT_DIR"
          done

      - name: Security verification
        run: |
          OUTPUT_DIR="$GITHUB_WORKSPACE/private-repo/${{ secrets.PRIVATE_DIR }}/1cut"
          # 验证元数据
          find "$OUTPUT_DIR" -name "*.pdf" -exec exiftool {} \;
          # 验证文件结构
          find "$OUTPUT_DIR" -name "*.pdf" -exec qpdf --check {} \;

      - name: Commit changes
        run: |
          cd private-repo
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git add .
          git commit -m "Secure PDF Process [$(date +'%Y%m%d-%H%M%S')]"
          git push "https://${{ secrets.PAT }}@github.com/${{ secrets.PRIVATE_REPO }}.git"
